# Сравнение аудио-потоков по малому информационному каналу

## Основа решения, dejavu, модернизация
Исходная билиотека была изменеа следующим обазом:
изначально при создании элемента класса dejavu создавалась бд с эталонными треками.
Этот момент был удален, в измененной версии создается только объект класса, без бд, который при получении фрагмента или
произведения не ищет автоматически, а возвращает массив хешей.(Также важный момент, что ранее возвращалось множесто хешей и временные сдвиги, сейчас множество замененно на массив, а сдвиги удалены)

С одной стороны для данной задачи переход к массиву лоигчен, поскольку работа с массивом лучше подходит под концепцию задачи
(цель исходной - найти совпадения в больой базе максимальное, в поставленной - опеределить степень схожести),
Однако данное преобразование пораждает проблему коллизий хешей. Её решение будет описано ниже, в файле main.


## Добавленные файлы
main.py
---
Основной запускаемый файл, в котором реализован процесс сравнения 2х аудио-файлов. На данный момент работает только для моно, в обратном случае учитывается только 1й канал.
Алгоритм состоит из 3х последовательных шагов:
1. вызывается функция хеширования для обоих треков(из файла hashing.py, подробности хеширования в этом разделе)
2. ищется "первая точка" фрагмента(уже на этом этапе может определиться, что фрагменты различимы)
3. проверяется на схожесть остальная часть фрагмента, беря в рассчет, что первая точка правильно определило полжение фрагмента.

Подробнее о 2 и 3 пунктах.

##### Определение первой точки:
Для каждого хеша ищется совпадение в первых 10/*tenSec - консанта из cfg, можно менять*/ секунах эталонного файла(считается, что разница потоков +- 10секунд)(для тестирования 10 секунд убиралось и поиск производился по всему массиву).
Отдельно сохраняются  идексы совпадений(ндексы искомого хеша в эталонном массиве). Если новый найднный индекс не лежит в окрестности совпавших ранее,
то он добавляется в солварь, хранящий возможные первые точки, как ключ.(зачения в данном словаре - количество послед. индексов в окрестности найденного).
В случае если посчитанный хеш лежит в окрестности одного из найднных ранее, он увеличивает его счетчик(значение) на один.

Если для какого-то ключа(возможной 1 точки) счетчик стал достаточно большим/*num_for_check_if_not_collision - консанта из cfg, можно менять*/, то данная последовательность считается начальной, а ключ - первая точка совпадения.

##### Проверка остальной части:
Последовательно ищутся хеши в небольшом возможном окне(+2/*allowDiffSec - консанта из cfg, можно менять*/ секунды от последнего совпадения)
При не нахождении достаточно большого количество хешей подряд/*allowDiffFrame - консанта из cfg, можно менять*/, считается, что фрагменты разные.
При совпадении, счетчик обнуляется, а новый хеш, который становится новой "первой точкой"(от которой ищутся в диапазоне 2секунд след хеши).

На данном этапе коллизии также могут стать причиной ложного резльтата. Поэтому для каждого совпавшего хеша проиводится следущая проверка:

```
 if tempInd - fr_ptr <= diffLen + hashes_diff: 
``` 
,где *fr_ptr* = индекс последней "истинно"-сопавшая точка, *tempInd* - индекс нового совпадения,
*diffLen* -  количество несовпавших хешей между ними, *hashes_diff* - разрешенная разница индексов
/*все константы прописаны в cfg.py*/



hashing.py
---
В данном файле создается объект класса dejavu и в последствии с его помощью вычесляется хеш. Таким образом это некая оболочка над библиотекой, сохраняющая лишь нжный в программе функционал.

parse_CMD.py
---
На вход получает и обрабатывает путь к эталонному треку, путь к искомому фрагменту, а также необязательный параметр - путь к конфиг файлу.

cfg.py
---
Параметры, выбранные эмпирически:
+ *framesInSecond* - количество фреймов в секунду
+ *closeIndexes* - в какой окрестности индексы считаются близкими, 2этап, поиск первой точки
+ *num_for_check_if_not_collision* - колиество индексов поряд, которые нужно набрать во 2 этапе, чтобы точка была выбрана 1
+ *diffForFirstAndNext* - окретность, в которой считается, что хеш увеличивает счетчик, а не становится новым возможным первым
+ *hashes_diff* - определение окрестности различий для 3 этапа


Параметры, выбранные логически(некоторые могут опираться на эмпирические):
+ *allowDiffSec* - количество секунд, которые считаются шумом, а не вставкой
+ *freq* - частота сэмплирования
+ *allowDiffFrame* = allowDiffSec * framesInSecond  - разрешенная длина шума в кадрах
+ *tenSec* = framesInSecond*10 # количество фреймов в 10 секундах

